# OS â€” Exercises, Diagrams and Exam Questions

## Part 2: Weeks 5â€“8 (Threads, Synchronisation, Deadlock)

> by Revolvix | ASE Bucharest â€” CSIE

### Difficulty Legend

| Symbol | Level | Time | Description |
|--------|-------|------|-------------|
| â­ | Easy | 3â€“5 min | Basic recall and understanding |
| â­â­ | Medium | 5â€“10 min | Application of concepts |
| â­â­â­ | Hard | 10â€“15 min | Analysis and calculation |
| â­â­â­â­ | Expert | 15â€“20 min | Evaluation and design |

> ğŸ’¡ **Study tip:** Synchronisation problems require careful step-by-step reasoning. Draw the timeline of thread execution to visualise race conditions.

---

# WEEK 5: Threads

## Detailed ASCII Diagrams

### Diagram 5.1: Thread vs Process Memory Layout

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    PROCESS vs THREAD - MEMORY LAYOUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TWO SEPARATE PROCESSES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    PROCESS A (PID 1000)                    PROCESS B (PID 2000)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Virtual Address Space A    â”‚      â”‚  Virtual Address Space B    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚     Kernel Space      â”‚  â”‚      â”‚  â”‚     Kernel Space      â”‚  â”‚
â”‚  â”‚      (shared)         â”‚  â”‚      â”‚  â”‚      (shared)         â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Stack          â”‚  â”‚      â”‚  â”‚        Stack          â”‚  â”‚
â”‚  â”‚       (own)           â”‚  â”‚      â”‚  â”‚       (own)           â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                       â”‚  â”‚      â”‚  â”‚                       â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Heap           â”‚  â”‚      â”‚  â”‚        Heap           â”‚  â”‚
â”‚  â”‚       (own)           â”‚  â”‚      â”‚  â”‚       (own)           â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚      Data/BSS         â”‚  â”‚      â”‚  â”‚      Data/BSS         â”‚  â”‚
â”‚  â”‚       (own)           â”‚  â”‚      â”‚  â”‚       (own)           â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Text           â”‚  â”‚      â”‚  â”‚        Text           â”‚  â”‚
â”‚  â”‚       (own)           â”‚  â”‚      â”‚  â”‚       (own)           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                    â”‚
            â–¼                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PHYSICAL MEMORY                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚Frame A1 â”‚ â”‚Frame A2 â”‚ â”‚Frame B1 â”‚ â”‚Frame B2 â”‚ â”‚ Kernel  â”‚       â”‚
â”‚  â”‚(Stack A)â”‚ â”‚(Heap A) â”‚ â”‚(Stack B)â”‚ â”‚(Heap B) â”‚ â”‚(shared) â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                     â”‚
â”‚  COMPLETE Isolation: A cannot access B's memory!                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ONE PROCESS WITH MULTIPLE THREADS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    PROCESS P (PID 1000) with 3 THREADS
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Virtual Address Space (SHARED)                      â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      Kernel Space                                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  Stack T1   â”‚    â”‚  Stack T2   â”‚    â”‚  Stack T3   â”‚  â† SEPARATE     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚                 â”‚
â”‚  â”‚  var_a = 5  â”‚    â”‚  var_a = 10 â”‚    â”‚  var_a = 15 â”‚  (local         â”‚
â”‚  â”‚  var_b = 2  â”‚    â”‚  var_b = 7  â”‚    â”‚  var_b = 9  â”‚   variables)    â”‚
â”‚  â”‚  ret_addr   â”‚    â”‚  ret_addr   â”‚    â”‚  ret_addr   â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚         â”‚                  â”‚                  â”‚                         â”‚
â”‚         â”‚    Thread ID     â”‚    Thread ID     â”‚    Thread ID           â”‚
â”‚         â”‚    Registers     â”‚    Registers     â”‚    Registers           â”‚
â”‚         â”‚    PC (Program   â”‚    PC            â”‚    PC         SEPARATE â”‚
â”‚         â”‚    Counter)      â”‚                  â”‚                         â”‚
â”‚         â”‚                  â”‚                  â”‚                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         HEAP                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚  shared_counter = 42                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  shared_array[] = [1, 2, 3, 4, 5]                       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  mutex = <locked by T2>                                  â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ S â”‚
â”‚  â”‚                                                                  â”‚ H â”‚
â”‚  â”‚  ANY THREAD CAN ACCESS ANYTHING IN HEAP!                        â”‚ A â”‚
â”‚  â”‚  â†’ SYNCHRONISATION REQUIRED!                                    â”‚ R â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ E â”‚
â”‚                                                                       D â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      DATA/BSS                                    â”‚   â”‚
â”‚  â”‚  global_config = "production"                                    â”‚   â”‚
â”‚  â”‚  log_level = 3                                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        TEXT                                      â”‚   â”‚
â”‚  â”‚  [executable instructions]                                       â”‚   â”‚
â”‚  â”‚  All threads execute the same code!                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    FILE DESCRIPTORS                              â”‚   â”‚
â”‚  â”‚  fd[0] = stdin                                                   â”‚   â”‚
â”‚  â”‚  fd[1] = stdout                                                  â”‚ S â”‚
â”‚  â”‚  fd[2] = stderr                                                  â”‚ H â”‚
â”‚  â”‚  fd[3] = /var/log/app.log                                       â”‚ A â”‚
â”‚  â”‚                                                                  â”‚ R â”‚
â”‚  â”‚  SHARED! One thread opens, all can use.                         â”‚ E â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ D â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPARATIVE SUMMARY:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚   SEPARATE PROCESSES     â”‚   THREADS (same process) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Address Space   â”‚ SEPARATE for each        â”‚ SHARED                   â”‚
â”‚ Text (Code)     â”‚ Copied/Separate          â”‚ SHARED                   â”‚
â”‚ Data/BSS        â”‚ SEPARATE                 â”‚ SHARED                   â”‚
â”‚ Heap            â”‚ SEPARATE                 â”‚ SHARED                   â”‚
â”‚ Stack           â”‚ SEPARATE                 â”‚ SEPARATE per thread      â”‚
â”‚ Registers       â”‚ SEPARATE                 â”‚ SEPARATE per thread      â”‚
â”‚ PC              â”‚ SEPARATE                 â”‚ SEPARATE per thread      â”‚
â”‚ File Descriptorsâ”‚ Copied at fork           â”‚ SHARED                   â”‚
â”‚ PID             â”‚ Different                â”‚ Same                     â”‚
â”‚ TID             â”‚ N/A                      â”‚ Different                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Isolation       â”‚ âœ… Complete              â”‚ âŒ Minimal               â”‚
â”‚ Communication   â”‚ IPC (pipes, sockets)     â”‚ Direct shared memory     â”‚
â”‚ Creation        â”‚ ~1-10 ms                 â”‚ ~10-100 Î¼s               â”‚
â”‚ Context Switch  â”‚ ~1-10 Î¼s + TLB flush     â”‚ ~0.1-1 Î¼s                â”‚
â”‚ Crash Impact    â”‚ Only that process        â”‚ Entire process dies      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Diagram 5.2: Multithreading Models

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    MULTITHREADING MODELS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         MODEL 1: MANY-TO-ONE (N:1)                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚     T1 â—    T2 â—    T3 â—    T4 â—    T5 â—                       â”‚   â•‘
â•‘    â”‚       \      |       |       |      /                           â”‚   â•‘
â•‘    â”‚        \     |       |       |     /                            â”‚   â•‘
â•‘    â”‚         \    |       |       |    /                             â”‚   â•‘
â•‘    â”‚          â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€                              â”‚   â•‘
â•‘    â”‚                    |                                             â”‚   â•‘
â•‘    â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚   â•‘
â•‘    â”‚     â”‚   User-Level Thread Library  â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   (Green Threads, Fibers)    â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   - Scheduling in user space â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   - Fast context switch      â”‚                             â”‚   â•‘
â•‘    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚   â•‘
â•‘    â”‚                    â”‚                                             â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                         â”‚                                                 â•‘
â•‘    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•‘
â•‘                         â”‚  A SINGLE kernel thread                         â•‘
â•‘    KERNEL SPACE         â–¼                                                 â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚                     K1 â—†                                        â”‚    â•‘
â•‘    â”‚               (kernel thread)                                   â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                                           â•‘
â•‘    âœ… Advantages:                   âŒ Disadvantages:                     â•‘
â•‘    â€¢ Fast switch between threads    â€¢ A blocking syscall blocks ALL       â•‘
â•‘    â€¢ Portable                       â€¢ Cannot exploit multi-core           â•‘
â•‘    â€¢ No kernel overhead             â€¢ One thread crash = whole process    â•‘
â•‘                                                                           â•‘
â•‘    ğŸ“Œ Examples: GNU Pth, Java Green Threads (old)                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         MODEL 2: ONE-TO-ONE (1:1)                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚     T1 â—         T2 â—         T3 â—         T4 â—                 â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘            â”‚            â”‚            â”‚            â”‚                       â•‘
â•‘    â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â•‘
â•‘            â”‚  1:1       â”‚  1:1       â”‚  1:1       â”‚  1:1                  â•‘
â•‘    KERNEL  â–¼            â–¼            â–¼            â–¼                       â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚     K1 â—†         K2 â—†         K3 â—†         K4 â—†                â”‚    â•‘
â•‘    â”‚   (kernel)     (kernel)     (kernel)     (kernel)               â”‚    â•‘
â•‘    â”‚    thread       thread       thread       thread                â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘            â”‚            â”‚            â”‚            â”‚                       â•‘
â•‘            â–¼            â–¼            â–¼            â–¼                       â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚     CPU 0       CPU 1       CPU 2       CPU 3                   â”‚    â•‘
â•‘    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”                 â”‚    â•‘
â•‘    â”‚   â”‚ Core â”‚    â”‚ Core â”‚    â”‚ Core â”‚    â”‚ Core â”‚                 â”‚    â•‘
â•‘    â”‚   â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜                 â”‚    â•‘
â•‘    â”‚              REAL PARALLELISM ON MULTI-CORE!                    â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                                           â•‘
â•‘    âœ… Advantages:                   âŒ Disadvantages:                     â•‘
â•‘    â€¢ Real multi-core parallelism    â€¢ Thread creation overhead            â•‘
â•‘    â€¢ One blocked thread doesn't     â€¢ Limit on number of threads          â•‘
â•‘      affect others                  â€¢ Switch via kernel (slower)          â•‘
â•‘    â€¢ Optimised kernel scheduler                                           â•‘
â•‘                                                                           â•‘
â•‘    ğŸ“Œ Examples: Linux NPTL, Windows Threads, macOS Threads               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                       MODEL 3: MANY-TO-MANY (M:N)                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚   T1 â—  T2 â—  T3 â—  T4 â—  T5 â—  T6 â—  T7 â—  T8 â—               â”‚   â•‘
â•‘    â”‚     \    |    /      \    |    /      \    /                    â”‚   â•‘
â•‘    â”‚      \   |   /        \   |   /        \  /                     â”‚   â•‘
â•‘    â”‚       \  |  /          \  |  /          \/                      â”‚   â•‘
â•‘    â”‚        \ | /            \ | /           /\                      â”‚   â•‘
â•‘    â”‚         â”€â”¼â”€              â”€â”¼â”€           /  \                     â”‚   â•‘
â•‘    â”‚     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”‚   â•‘
â•‘    â”‚     â”‚      User-Level Scheduler            â”‚                    â”‚   â•‘
â•‘    â”‚     â”‚  (multiplexes M user threads         â”‚                    â”‚   â•‘
â•‘    â”‚     â”‚   onto N kernel threads)             â”‚                    â”‚   â•‘
â•‘    â”‚     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜                    â”‚   â•‘
â•‘    â”‚          â”‚                â”‚            â”‚                        â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘               â”‚                â”‚            â”‚                            â•‘
â•‘    â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â•‘
â•‘               â”‚  M:N           â”‚            â”‚                            â•‘
â•‘    KERNEL     â–¼                â–¼            â–¼                            â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚          K1 â—†            K2 â—†         K3 â—†                     â”‚   â•‘
â•‘    â”‚       (kernel)         (kernel)      (kernel)                   â”‚   â•‘
â•‘    â”‚        thread           thread        thread                    â”‚   â•‘
â•‘    â”‚                                                                 â”‚   â•‘
â•‘    â”‚    8 user threads multiplexed onto 3 kernel threads!           â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                                                                          â•‘
â•‘    âœ… Advantages:                   âŒ Disadvantages:                    â•‘
â•‘    â€¢ Flexible (M >> N or M = N)     â€¢ Complex to implement               â•‘
â•‘    â€¢ Combines N:1 and 1:1 benefits  â€¢ Synchronisation between schedulers â•‘
â•‘    â€¢ Can scale thousands of threads â€¢ Difficult debugging                â•‘
â•‘                                                                          â•‘
â•‘    ğŸ“Œ Examples: Go goroutines, Erlang processes, Solaris (historic)     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Solved Exercises

### Exercise 5.1: Threads vs Processes Analysis

Problem: For each scenario, decide whether threads or separate processes should be used. Justify.

| Scenario | Recommendation | Justification |
|----------|----------------|---------------|
| Web server handling 10,000 simultaneous requests | Threads (or async I/O) | Requests are independent but share config, DB connections. Threads are lighter. |
| Browser with multiple tabs | Separate processes for tabs | Isolation: a compromised/crashed tab doesn't affect others (security, stability) |
| Scientific computing application with shared data | Threads | Need fast access to shared data; low communication overhead |
| Video processing pipeline | Processes connected with pipes | Each stage is independent, can crash separately, can be rewritten in another language |
| Video game with rendering and physics | Threads | Need tight synchronisation, low latency, game state sharing |

---

### Exercise 5.2: Thread Safety

Problem: Identify the problems in the following code and correct them.

```python
# PROBLEMATIC CODE
import threading

counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter = counter + 1  # PROBLEM!

threads = [threading.Thread(target=increment) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(counter)  # Should be 400000, but probably smaller!
```

Solution:

```python
# CORRECTED CODE - Variant 1: Lock
import threading

counter = 0
lock = threading.Lock()

def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # Protected critical section
            counter = counter + 1

# Variant 2: Atomics (threading has Lock, but no atomic counter)
# In practice, use Lock or Queue

# Variant 3: Avoid shared state - each thread counts locally
def increment_local():
    local_count = 0
    for _ in range(100000):
        local_count += 1
    return local_count

# Then sum the results
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(increment_local) for _ in range(4)]
    total = sum(f.result() for f in futures)
print(total)  # 400000 guaranteed!
```

---

## Exam-Style Questions

5.1 (Multiple Choice) What do threads of the same process share?
- a) Stack
- b) CPU Registers
- c) Program Counter
- d) Heap âœ“

---

5.2 (Multiple Choice) In the 1:1 model, if a thread makes a blocking syscall:
- a) All threads block
- b) Only that thread blocks âœ“
- c) The entire process is terminated
- d) The kernel automatically creates a new thread

---

5.3 (5p) Explain why creating a thread is faster than creating a new process.

Model answer:

Creating a thread is faster for several reasons:

1. No address space duplication (2p):
   - Fork() copies page tables (even with CoW)
   - Thread: only allocates a new stack (~8KB)

2. No new security settings (1p):
   - New process: UID/GID verification, setting capabilities
   - Thread: inherits everything from process

3. No PID allocation (0.5p):
   - Process: kernel allocates new PID
   - Thread: only TID (simpler)

4. No file descriptor duplication (0.5p):
   - Fork: copies the fd table
   - Thread: shares directly

5. Fewer syscalls (1p):
   - Fork: `fork()` + complete setup
   - Thread: `clone(CLONE_VM|CLONE_FILES|...)` with flags saying "share everything"

---

# WEEK 6: Synchronisation I

## Detailed ASCII Diagrams

### Diagram 6.1: Race Condition Visualised

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                         RACE CONDITION - VISUALISATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Problem: counter++ is NOT atomic!

Code:
    counter = counter + 1

Decomposes into 3 instructions:
    1. LOAD  counter â†’ register
    2. ADD   1 â†’ register
    3. STORE register â†’ counter

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CORRECT SCENARIO (without interleaving):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

counter = 0

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) LOAD  counter â†’ regA = 0
(2) ADD   1 â†’ regA = 1
(3) STORE regA â†’ counter = 1
                                    (4) LOAD  counter â†’ regB = 1
                                    (5) ADD   1 â†’ regB = 2
                                    (6) STORE regB â†’ counter = 2

Final result: counter = 2 âœ“

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SCENARIO WITH RACE CONDITION (problematic interleaving):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

counter = 0

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) LOAD  counter â†’ regA = 0
                                    (2) LOAD  counter â†’ regB = 0
(3) ADD   1 â†’ regA = 1
                                    (4) ADD   1 â†’ regB = 1
(5) STORE regA â†’ counter = 1
                                    (6) STORE regB â†’ counter = 1

Final result: counter = 1 âœ— (should be 2!)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VISUAL TIMELINE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Time    Thread A              Memory            Thread B
â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€

 t0     LOAD (0)              counter=0                         
        regA â† 0                               
                                               
 t1                           counter=0         LOAD (0)
                                                regB â† 0
                                               
 t2     ADD                   counter=0                
        regA = 1                               
                                               
 t3                           counter=0         ADD
                                                regB = 1
                                               
 t4     STORE                 counter=1                
        counter â† regA                         
                                               
 t5                           counter=1         STORE
                                                counter â† regB
                                               
 t6                           counter=1  â† WRONG!
                              (lost an increment)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUTION WITH LOCK:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
acquire(lock)                       
  (1) LOAD  counter â†’ regA = 0      |
  (2) ADD   1 â†’ regA = 1            |  acquire(lock) â†’ BLOCKED!
  (3) STORE regA â†’ counter = 1      |  (waiting...)
release(lock)                       |
                                    |  (lock available!)
                                    acquire(lock)
                                      (4) LOAD  counter â†’ regB = 1
                                      (5) ADD   1 â†’ regB = 2
                                      (6) STORE regB â†’ counter = 2
                                    release(lock)

Final result: counter = 2 âœ“
```

### Diagram 6.2: Critical Section and Properties

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    CRITICAL SECTION - STRUCTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        STANDARD STRUCTURE                               â”‚
â”‚                                                                         â”‚
â”‚   while (true) {                                                        â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         ENTRY SECTION                       â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  Request access to critical section         â”‚                  â”‚
â”‚       â”‚  Ex: acquire(lock), wait(mutex)             â”‚                  â”‚
â”‚       â”‚  May block if someone is inside             â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                  â”‚
â”‚       â•‘         CRITICAL SECTION                    â•‘                  â”‚
â”‚       â•‘  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•          â•‘                  â”‚
â”‚       â•‘  Access the shared resource                 â•‘                  â”‚
â”‚       â•‘  Ex: counter++, read/write shared data      â•‘                  â”‚
â”‚       â•‘                                             â•‘                  â”‚
â”‚       â•‘  âš ï¸ MAXIMUM ONE PROCESS HERE AT ANY TIME!  â•‘                  â”‚
â”‚       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         EXIT SECTION                        â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  Release access                             â”‚                  â”‚
â”‚       â”‚  Ex: release(lock), signal(mutex)           â”‚                  â”‚
â”‚       â”‚  Allow others to enter                      â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         REMAINDER SECTION                   â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  Code that doesn't access shared resource   â”‚                  â”‚
â”‚       â”‚  Can run in parallel with others            â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚   }                                                                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
THE 3 REQUIRED PROPERTIES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  1ï¸âƒ£ MUTUAL EXCLUSION                                                   â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                   â”‚
â”‚                                                                         â”‚
â”‚  "If process Pi is executing in its critical section,                  â”‚
â”‚   no other process Pj can be in its critical section."                 â”‚
â”‚                                                                         â”‚
â”‚       CS                         CS                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚         â”‚                â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚                               â”‚
â”‚   â”‚   P1    â”‚                â”‚ BLOCKED!â”‚ P2                            â”‚
â”‚   â”‚         â”‚                â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                         â”‚
â”‚   Metaphor: Only one person in the toilet at a time.                   â”‚
â”‚                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  2ï¸âƒ£ PROGRESS                                                            â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•                                                           â”‚
â”‚                                                                         â”‚
â”‚  "If no process is in CS and some processes want to enter,             â”‚
â”‚   the selection cannot be postponed indefinitely."                     â”‚
â”‚                                                                         â”‚
â”‚       CS (empty)                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        P1: "I want to enter!"                            â”‚
â”‚   â”‚ (empty) â”‚        P2: "Me too!"                                     â”‚
â”‚   â”‚         â”‚                                                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â†’ One of them MUST be able to enter!              â”‚
â”‚                                                                         â”‚
â”‚   Metaphor: If the toilet is free and people are waiting,              â”‚
â”‚             someone must be able to enter (it doesn't stay empty).     â”‚
â”‚                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  3ï¸âƒ£ BOUNDED WAITING                                                     â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                    â”‚
â”‚                                                                         â”‚
â”‚  "There is a limit on the number of times other processes              â”‚
â”‚   can enter CS after a process has requested access."                  â”‚
â”‚                                                                         â”‚
â”‚   P1 requests access: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚                       â”‚ Max N "bypasses" until P1 enters    â”‚          â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚   Metaphor: In a queue, you can't be skipped by infinitely many people.â”‚
â”‚                                                                         â”‚
â”‚   Counter-example (starvation):                                        â”‚
â”‚   P1 waits, but P2, P3, P4... always enter before â†’ P1 starves         â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Solved Exercises

### Exercise 6.1: Lock Implementation with TAS

Problem: Implement a spinlock using Test-and-Set in pseudocode.

Solution:

```c
// Atomic Test-and-Set (provided by hardware)
bool test_and_set(bool *target) {
    bool old = *target;
    *target = true;
    return old;
}

// Spinlock implementation
typedef struct {
    bool locked;
} spinlock_t;

void spinlock_init(spinlock_t *lock) {
    lock->locked = false;
}

void spinlock_acquire(spinlock_t *lock) {
    // Spin until we manage to set locked from false to true
    while (test_and_set(&lock->locked)) {
        // Busy wait (consumes CPU)
        // Optimisation: yield() or pause instruction
    }
    // Now we have the lock!
}

void spinlock_release(spinlock_t *lock) {
    lock->locked = false;
}
```

Property verification:
- Mutual Exclusion: âœ… Only one thread can set locked from false to true
- Progress: âœ… If lock is free (false), TAS will return false and thread enters
- Bounded Waiting: âŒ Not guaranteed! A thread can be "unlucky" and wait indefinitely

---

### Exercise 6.2: Peterson's Algorithm

Problem: Demonstrate that Peterson's algorithm satisfies mutual exclusion for 2 processes.

Solution:

```c
bool flag[2] = {false, false};  // flag[i] = process i wants to enter
int turn;                        // whose turn it is

// Process P0                     // Process P1
flag[0] = true;                  flag[1] = true;
turn = 1;                        turn = 0;
while (flag[1] && turn == 1)     while (flag[0] && turn == 0)
    ; // wait                        ; // wait
// CRITICAL SECTION              // CRITICAL SECTION
flag[0] = false;                 flag[1] = false;
```

Mutual Exclusion Proof:

Let's assume BOTH processes are in CS simultaneously (contradiction).

1. P0 passed the while â†’ `Â¬(flag[1] âˆ§ turn=1)` â†’ `Â¬flag[1] âˆ¨ turn=0`
2. P1 passed the while â†’ `Â¬(flag[0] âˆ§ turn=0)` â†’ `Â¬flag[0] âˆ¨ turn=1`

But both flag[i] = true when they want to enter. So:
- From (1): turn = 0 (because flag[1] = true)
- From (2): turn = 1 (because flag[0] = true)

Contradiction! turn cannot be both 0 and 1 simultaneously. â–¡

---

## Exam-Style Questions

> âš ï¸ **Common mistake:** Students often confuse the order of semaphore operations. Remember: acquire mutex AFTER checking empty/full, release mutex BEFORE signalling. Wrong order causes deadlock!

6.1 (Multiple Choice) â­ What is the main difference between spinlock and mutex?
- a) Spinlock is faster
- b) Spinlock does busy-wait, mutex does sleep âœ“
- c) Mutex can only be used for 2 processes
- d) Spinlock guarantees bounded waiting

---

6.2 (5p) â­â­â­ A system has 3 processes P1, P2, P3 accessing a shared counter. Each process increments the counter 1000 times. Initially the counter is 0.

a) What is the expected value of the counter without synchronisation?
b) What is the minimum possible value? Explain.
c) How do you solve the problem?

Answer:

```
a) Expected value (if everything were correct): 3000

b) Minimum value: 3 (in the worst theoretical case, almost 1000)

   Explanation for extreme theoretical minimum:
   - All threads read 0 simultaneously â€” and related to this, all add 1
   - All write 1
   - Repeat: read 1, add 1, write 1
   - ... until one finishes
   
   In practice, the minimum is hard to reach but can be significantly
   less than 3000. Typically: ~1000-2500.

c) Solution: Protect with mutex/lock

   mutex_t lock;
   
   void increment() {
       for (int i = 0; i < 1000; i++) {
           lock(&lock);
           counter++;
           unlock(&lock);
       }
   }
   
   Or use atomic operations:
   __sync_fetch_and_add(&counter, 1);
```

---

# WEEK 7: Synchronisation II (Semaphores)

## Detailed ASCII Diagrams

### Diagram 7.1: Producer-Consumer with Semaphores

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    PRODUCER-CONSUMER WITH SEMAPHORES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROBLEM:
- Buffer of size N
- Producer: puts elements (blocks if buffer full)
- Consumer: takes elements (blocks if buffer empty)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REQUIRED SEMAPHORES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  empty = N     // How many EMPTY slots (initially all N are empty)      â”‚
â”‚  full  = 0     // How many elements AVAILABLE (initially none)          â”‚
â”‚  mutex = 1     // Exclusive access to buffer (binary)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INITIAL STATE (N=5):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚     â”‚     â”‚     â”‚     â”‚     â”‚   Buffer (all empty)
â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
  [0]   [1]   [2]   [3]   [4]

empty = 5 â—â—â—â—â—        full = 0 (empty)        mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRODUCER ADDS ELEMENT:

    1. wait(empty)    // Take an "empty slot" (empty: 5â†’4)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 1 â—
    
    2. wait(mutex)    // Enter CS (mutex: 1â†’0)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 0 (locked)
    
    3. buffer[in] = item; in = (in+1)%N;
    
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚     â”‚     â”‚     â”‚   Element added!
    â”‚ A   â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚     â”‚     â”‚     â”‚
    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
      [0]   [1]   [2]   [3]   [4]
       â†‘
      in=1
    
    4. signal(mutex)  // Exit CS (mutex: 0â†’1)
    
    5. signal(full)   // Announce new element (full: 0â†’1)
    
    empty = 4 â—â—â—â—        full = 1 â—           mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONSUMER TAKES ELEMENT:

    1. wait(full)     // Take an "available element" (full: 1â†’0)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 1 â—
    
    2. wait(mutex)    // Enter CS (mutex: 1â†’0)
    
    3. item = buffer[out]; out = (out+1)%N;
    
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚     â”‚     â”‚     â”‚     â”‚     â”‚   Element taken!
    â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
    â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
       â†‘
      out=1
    
    4. signal(mutex)  // Exit CS (mutex: 0â†’1)
    
    5. signal(empty)  // Announce free slot (empty: 4â†’5)
    
    empty = 5 â—â—â—â—â—       full = 0             mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BLOCKING SCENARIO:

FULL buffer (N=5 elements):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
â”‚  A  â”‚  B  â”‚  C  â”‚  D  â”‚  E  â”‚
â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

empty = 0 (empty!)    full = 5 â—â—â—â—â—        mutex = 1 â—

Producer tries: wait(empty)
â†’ empty = 0, so BLOCKS!
â†’ Producer sleeps until someone does signal(empty)

Consumer takes element, does signal(empty) â†’ empty = 1
â†’ Producer wakes up and continues!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ COMMON MISTAKE - WAIT ORDER:

WRONG:                           CORRECT:
â”€â”€â”€â”€â”€â”€                           â”€â”€â”€â”€â”€â”€â”€
wait(mutex)                      wait(empty)     // First check slot
wait(empty) â† DEADLOCK!          wait(mutex)     // Then take mutex

If buffer full:
- Thread takes mutex
- Blocks on empty
- But holds mutex!
- Consumer can't enter to release!
- DEADLOCK!
```

---

## Solved Exercises

### Exercise 7.1: Readers-Writers

Problem: Implement the "readers preference" solution for the readers-writers problem.

Solution:

```c
semaphore rw_mutex = 1;     // Resource access (writers or first/last reader)
semaphore mutex = 1;        // Protects read_count
int read_count = 0;         // How many active readers

void reader() {
    wait(mutex);            // Protect read_count
    read_count++;
    if (read_count == 1)    // First reader?
        wait(rw_mutex);     // Block writers!
    signal(mutex);
    
    // READ DATA (many readers simultaneously)
    
    wait(mutex);
    read_count--;
    if (read_count == 0)    // Last reader?
        signal(rw_mutex);   // Allow writers
    signal(mutex);
}

void writer() {
    wait(rw_mutex);         // Exclusive access
    
    // WRITE DATA (single writer)
    
    signal(rw_mutex);
}
```

Explanation: 
- First reader takes rw_mutex â†’ blocks writers
- Subsequent readers enter directly (rw_mutex already taken)
- Last reader releases rw_mutex
- Writers can only enter when read_count = 0

Problem: Writers can starve if new readers keep arriving!

---

## Exam-Style Questions

7.1 (Multiple Choice) A counting semaphore with initial value 3 can allow:
- a) Maximum 1 process in the critical section
- b) Maximum 3 processes simultaneously in the critical section âœ“
- c) Infinite processes
- d) Exactly 3 processes (no fewer)

---

7.2 (5p) Explain the difference between wait() on a semaphore and wait() on a condition variable.

Answer:

| Aspect | Semaphore wait() | Condition Variable wait() |
|--------|------------------|---------------------------|
| Lock | Does NOT affect any lock | RELEASES the associated lock |
| Memory | Remembers signals (counts) | Does NOT remember - signal lost if no one waiting |
| On signal | Decrements counter | Only wakes, doesn't guarantee condition |
| Check | No need for while | MUST use while (condition may be false again) |
| Semantics | Counting resource | Notification/wait on condition |

Concrete example:
```c
// Semaphore
signal(sem);  // Even if no one is waiting, sem increases
...           // Later:
wait(sem);    // Will succeed immediately (sem > 0)

// CV
signal(cv);   // If no one is waiting, LOST!
...           // Later:
wait(cv);     // Will block forever!
```

---

# WEEK 8: Deadlock

## Detailed ASCII Diagrams

### Diagram 8.1: Coffman Conditions Visualised

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    THE 4 COFFMAN CONDITIONS - VISUALISATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

All 4 conditions MUST be present simultaneously for deadlock!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1ï¸âƒ£ MUTUAL EXCLUSION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"The resource can be held by at most one process at a time"

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    RESOURCE  â”‚
    â”‚   (printer)  â”‚
    â”‚              â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚ P1 ğŸ”’  â”‚  â”‚  â† P1 holds resource exclusively
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚              â”‚
    â”‚   P2 â³ P3 â³ â”‚  â† P2, P3 waiting
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

If the resource could be shared (e.g. read-only file), no problem!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2ï¸âƒ£ HOLD AND WAIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Process holds resources and waits for others"

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                P1                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
    â”‚  â”‚   R1    â”‚  wants â†’ â”‚   R2    â”‚     â”‚
    â”‚  â”‚  (has)  â”‚         â”‚(doesn't â”‚     â”‚
    â”‚  â”‚  ğŸ”’     â”‚    â³    â”‚  have)  â”‚     â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

P1 holds R1 tight and refuses to give it up before receiving R2!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3ï¸âƒ£ NO PREEMPTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Resource cannot be forcibly taken - only the process can release voluntarily"

         P2: "Give me R1!"
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        P1           â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚   â”‚   R1    â”‚       â”‚  P1: "NO! It's mine!"
    â”‚   â”‚   ğŸ”’    â”‚ âœ‹     â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    (No one can snatch R1 from P1's hands)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4ï¸âƒ£ CIRCULAR WAIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"There is a cycle of waiting"

           P1 â”€â”€â”€â”€â”€â”€(waits for R2)â”€â”€â”€â”€â”€â”€â–¶ P2
            â–²                            â”‚
            â”‚                            â”‚
       (has R1)                     (has R2)
            â”‚                            â”‚
            â”‚                            â–¼
           P4 â—€â”€â”€â”€â”€(waits for R4)â”€â”€â”€â”€â”€â”€ P3
            â”‚                            â–²
       (has R4)                     (has R3)
            â”‚                            â”‚
            â””â”€â”€â”€â”€(waits for R3)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Cycle: P1â†’P2â†’P3â†’P4â†’P1
    All waiting, no one can progress â†’ DEADLOCK!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPLETE EXAMPLE - DINING PHILOSOPHERS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5 philosophers, 5 forks, each takes left fork first.

        F0            Each philosopher (P) needs
   P0 â—    â— P1       2 forks to eat.
  F4 â”‚      â”‚ F1
     â—â”€â”€â”€â”€â”€â”€â—         All take left fork simultaneously:
    P4      P2        
     â”‚      â”‚         P0 takes F0
  F3 â—â”€â”€â”€â”€â”€â”€â— F2      P1 takes F1
        P3            P2 takes F2
                      P3 takes F3
                      P4 takes F4

Now each waits for right fork:
P0 waits for F1 (held by P1)
P1 waits for F2 (held by P2)
P2 waits for F3 (held by P3)
P3 waits for F4 (held by P4)
P4 waits for F0 (held by P0)

CYCLE: P0â†’P1â†’P2â†’P3â†’P4â†’P0 â†’ DEADLOCK!
All have a fork (Hold), all wait for another (Wait), there's a cycle (Circular).
```

### Diagram 8.2: Banker's Algorithm

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    BANKER'S ALGORITHM - COMPLETE EXAMPLE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

System with 5 processes (P0-P4) and 3 resource types (A, B, C).
Total resources: A=10, B=5, C=7

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CURRENT STATE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Allocation          Maximum            Need (Max-Alloc)
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
      â”‚ A  â”‚ B  â”‚ C  â”‚   â”‚ A  â”‚ B  â”‚ C  â”‚   â”‚ A  â”‚ B  â”‚ C  â”‚
  â”Œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P0 â”‚ 0  â”‚ 1  â”‚ 0  â”‚   â”‚ 7  â”‚ 5  â”‚ 3  â”‚   â”‚ 7  â”‚ 4  â”‚ 3  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P1 â”‚ 2  â”‚ 0  â”‚ 0  â”‚   â”‚ 3  â”‚ 2  â”‚ 2  â”‚   â”‚ 1  â”‚ 2  â”‚ 2  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P2 â”‚ 3  â”‚ 0  â”‚ 2  â”‚   â”‚ 9  â”‚ 0  â”‚ 2  â”‚   â”‚ 6  â”‚ 0  â”‚ 0  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P3 â”‚ 2  â”‚ 1  â”‚ 1  â”‚   â”‚ 2  â”‚ 2  â”‚ 2  â”‚   â”‚ 0  â”‚ 1  â”‚ 1  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P4 â”‚ 0  â”‚ 0  â”‚ 2  â”‚   â”‚ 4  â”‚ 3  â”‚ 3  â”‚   â”‚ 4  â”‚ 3  â”‚ 1  â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Total allocated: A=7, B=2, C=5
Available:       A=3, B=3, C=2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SAFETY ALGORITHM - FINDING SAFE SEQUENCE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Work = Available = [3, 3, 2]
Finish = [false, false, false, false, false]

ITERATION 1: Search for process with Need â‰¤ Work
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[3,3,2]? NO (7>3)
  P1: Need=[1,2,2] â‰¤ Work=[3,3,2]? YES! âœ“
  
  â†’ P1 can finish
  â†’ Work = Work + Allocation[P1] = [3,3,2] + [2,0,0] = [5,3,2]
  â†’ Finish[P1] = true
  
                    Work = [5, 3, 2]

ITERATION 2:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[5,3,2]? NO
  P2: Need=[6,0,0] â‰¤ Work=[5,3,2]? NO (6>5)
  P3: Need=[0,1,1] â‰¤ Work=[5,3,2]? YES! âœ“
  
  â†’ P3 can finish
  â†’ Work = [5,3,2] + [2,1,1] = [7,4,3]
  â†’ Finish[P3] = true
  
                    Work = [7, 4, 3]

ITERATION 3:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[7,4,3]? YES! âœ“
  
  â†’ P0 can finish
  â†’ Work = [7,4,3] + [0,1,0] = [7,5,3]
  â†’ Finish[P0] = true
  
                    Work = [7, 5, 3]

ITERATION 4:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P2: Need=[6,0,0] â‰¤ Work=[7,5,3]? YES! âœ“
  
  â†’ P2 can finish
  â†’ Work = [7,5,3] + [3,0,2] = [10,5,5]
  â†’ Finish[P2] = true
  
                    Work = [10, 5, 5]

ITERATION 5:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P4: Need=[4,3,1] â‰¤ Work=[10,5,5]? YES! âœ“
  
  â†’ P4 can finish
  â†’ Finish[P4] = true

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RESULT: SAFE STATE!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Safe sequence: <P1, P3, P0, P2, P4>

All processes can finish in this order.
```

---

## Solved Exercises

### Exercise 8.1: Deadlock Detection

Problem: Draw the allocation graph and determine if deadlock exists.

Processes: P1, P2, P3
Resources: R1 (1 instance), R2 (2 instances), R3 (1 instance)

Current state:
- P1 holds R1, requests R2
- P2 holds one instance of R2, requests R3
- P3 holds R3, requests R1

Solution:

```
Allocation graph:

    P1 â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ R2 â–¡â–¡    (P1 requests R2)
       â”‚                â”‚
       â”‚                â”‚ (R2 allocated to P2)
       â”‚                â–¼
    R1 â–¡ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ P2 â—â”€â”€â”€â”€â†’ R3 â–¡   (P2 requests R3)
       â”‚                            â”‚
       â”‚ (R1 allocated to P1)       â”‚ (R3 allocated to P3)
       â”‚                            â–¼
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ P3 â— (P3 requests R1)
       
Cycle: P1 â†’ R2 â†’ P2 â†’ R3 â†’ P3 â†’ R1 â†’ P1

WITH ONE INSTANCE PER RESOURCE: DEADLOCK CONFIRMED!

R2 has 2 instances, but one is held by P2 and the other is free!
â†’ P1 can receive R2!
â†’ P1 can finish
â†’ Releases R1
â†’ P3 can receive R1
â†’ P3 can finish
â†’ ... all can finish

RESULT: NO deadlock (R2 has a free instance).
```

---

## Exam-Style Questions

8.1 (Multiple Choice) Which Coffman condition can be eliminated through "resource ordering"?
- a) Mutual Exclusion
- b) Hold and Wait
- c) No Preemption
- d) Circular Wait âœ“

---

8.2 (7p) For the state below, apply the Banker's algorithm to verify if the system is in a safe state.

```
Processes: P0, P1, P2
Resources: A=9, B=3
Allocation: P0=[2,0], P1=[1,1], P2=[2,1]
Maximum:    P0=[4,2], P1=[3,2], P2=[7,2]
```

Answer:

```
1. Calculate Need = Max - Allocation:
   P0: [4,2] - [2,0] = [2,2]
   P1: [3,2] - [1,1] = [2,1]
   P2: [7,2] - [2,1] = [5,1]

2. Calculate Available:
   Total: [9,3]
   Allocated: [2+1+2, 0+1+1] = [5,2]
   Available = [9,3] - [5,2] = [4,1]

3. Safety Algorithm:
   Work = [4,1], Finish = [F, F, F]

   Step 1: Search for Need â‰¤ Work
   - P0: [2,2] â‰¤ [4,1]? NO (2>1 for B)
   - P1: [2,1] â‰¤ [4,1]? YES!
   â†’ P1 finishes, Work = [4,1] + [1,1] = [5,2]

   Step 2:
   - P0: [2,2] â‰¤ [5,2]? YES!
   â†’ P0 finishes, Work = [5,2] + [2,0] = [7,2]

   Step 3:
   - P2: [5,1] â‰¤ [7,2]? YES!
   â†’ P2 finishes

4. Safe sequence: <P1, P0, P2>
   
   THE SYSTEM IS IN A SAFE STATE! âœ“
```

---

*Continued in the next file with Weeks 9â€“14...*

---

## Advanced Exercises (Evaluate & Create)

> ğŸ’¡ **Industry relevance:** Synchronisation bugs are among the hardest to debug in production systems. These exercises simulate real debugging scenarios.

### E2.1: Deadlock Analysis (Evaluate) â­â­â­â­
**Difficulty:** Expert | **Time:** ~15 min | **Bloom Level:** Evaluate

A database system uses the following locking protocol for transactions:

```
Transaction T1:          Transaction T2:          Transaction T3:
lock(A)                  lock(B)                  lock(C)
lock(B)                  lock(C)                  lock(A)
// work                  // work                  // work
unlock(B)                unlock(C)                unlock(A)
unlock(A)                unlock(B)                unlock(C)
```

**Task:** Analyse this system for deadlock potential:

a) Draw the resource allocation graph if all transactions start simultaneously
b) Identify if deadlock can occur â€” if yes, give a specific interleaving
c) Evaluate three different solutions and recommend the best one:
   - Solution 1: Global lock ordering (always acquire A, B, C in alphabetical order)
   - Solution 2: Timeout with retry (abort after 100ms, retry with exponential backoff)
   - Solution 3: Deadlock detection with victim selection (abort youngest transaction)

**Model Answer:**
```
a) Resource Allocation Graph (all started simultaneously):
   
   T1 â”€â”€holdsâ”€â”€â–º A â—„â”€â”€waitsâ”€â”€ T3
   â”‚                          â”‚
   waits                      holds
   â”‚                          â”‚
   â–¼                          â–¼
   B â—„â”€â”€holdsâ”€â”€ T2 â”€â”€waitsâ”€â”€â–º C
   
   CYCLE EXISTS: T1 â†’ B â†’ T2 â†’ C â†’ T3 â†’ A â†’ T1

b) Deadlock interleaving:
   
   Time    T1          T2          T3
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   t1      lock(A)âœ“
   t2                  lock(B)âœ“
   t3                              lock(C)âœ“
   t4      lock(B)â³               
   t5                  lock(C)â³
   t6                              lock(A)â³
   
   â†’ DEADLOCK: circular wait established

c) Solution Evaluation:

   SOLUTION 1 - Global Lock Ordering:
   + Prevents deadlock completely (breaks circular wait)
   + Zero runtime overhead
   + Simple to implement
   - Requires code refactoring (T2, T3 must change)
   - May reduce parallelism (all wait for A first)
   
   SOLUTION 2 - Timeout with Retry:
   + No code changes to lock order
   + Self-healing
   - Wasted work (aborted transactions)
   - Livelock risk with identical timeouts
   - Hard to tune timeout value
   
   SOLUTION 3 - Deadlock Detection:
   + Deadlock only aborts when necessary
   + Minimal wasted work
   - Detection overhead (graph cycle detection)
   - Implementation complexity
   - Requires victim selection policy

   RECOMMENDATION: Solution 1 (Global Lock Ordering)
   
   Rationale: In a database with well-defined resources, lock ordering
   is the gold standard. It provides compile-time guarantees with zero
   runtime cost. The refactoring effort is one-time, whilst Solutions 2
   and 3 have ongoing performance and complexity costs.
```

---

### E2.2: Synchronisation Design (Create) â­â­â­â­
**Difficulty:** Expert | **Time:** ~20 min | **Bloom Level:** Create

**Scenario:** Design a thread-safe bounded buffer for a high-frequency trading system with these requirements:

| Requirement | Specification |
|-------------|---------------|
| Buffer size | 1024 messages |
| Producers | Multiple (up to 16 market data feeds) |
| Consumers | Multiple (up to 8 trading algorithms) |
| Latency target | < 1 microsecond for enqueue/dequeue |
| Ordering | FIFO within each producer |
| Overflow policy | Drop oldest message (never block producer) |

**Task:** Design the synchronisation solution:

a) Choose appropriate synchronisation primitives (justify your choice)
b) Provide pseudocode for enqueue() and dequeue() operations
c) Explain how your design meets the latency requirement
d) Discuss trade-offs you made

**Model Answer:**
```
a) Synchronisation Primitives:

   CHOSEN: Lock-free circular buffer with atomic operations
   
   NOT mutex/semaphore because:
   - Mutex: ~25ns best case, up to 1Î¼s with contention
   - Semaphore: Similar overhead plus kernel involvement
   - Neither meets <1Î¼s target under high contention
   
   Data Structures:
   - Circular array: Message buffer[1024]
   - Atomic head: position for next write
   - Atomic tail: position for next read  
   - Per-slot sequence numbers for ABA prevention

b) Pseudocode:

   struct Slot {
       atomic<uint64_t> sequence;
       Message data;
   };
   
   Slot buffer[1024];
   atomic<uint64_t> head = 0;
   atomic<uint64_t> tail = 0;
   
   bool enqueue(Message msg) {
       uint64_t pos = head.fetch_add(1, relaxed);
       uint64_t index = pos & 1023;  // Fast modulo for power of 2
       Slot* slot = &buffer[index];
       
       // Wait for slot to be consumed (or overwrite if overflow)
       uint64_t expected_seq = pos;
       while (slot->sequence.load(acquire) != expected_seq) {
           if (pos - tail.load(relaxed) >= 1024) {
               // Overflow: oldest message will be dropped
               break;
           }
           _mm_pause();  // CPU hint for spin-wait
       }
       
       slot->data = msg;
       slot->sequence.store(pos + 1, release);
       return true;
   }
   
   bool dequeue(Message* msg) {
       uint64_t pos = tail.load(relaxed);
       Slot* slot = &buffer[pos & 1023];
       uint64_t seq = slot->sequence.load(acquire);
       
       if (seq != pos + 1) {
           return false;  // Buffer empty
       }
       
       if (tail.compare_exchange_weak(pos, pos + 1, relaxed)) {
           *msg = slot->data;
           slot->sequence.store(pos + 1024, release);
           return true;
       }
       return false;  // Contention, retry
   }

c) Latency Analysis:

   - No system calls (pure user-space)
   - No context switches (lock-free)
   - Cache-line optimised (64-byte slot alignment)
   - fetch_add: ~10-20 cycles on modern x86
   - Memory barriers: ~20-40 cycles
   - Total: ~100-200 cycles â‰ˆ 30-60 nanoseconds
   
   This is well under the 1Î¼s requirement even with moderate contention.

d) Trade-offs:

   ACCEPTED:
   - Message loss under overflow (acceptable per requirements)
   - Higher memory usage (padding for cache alignment)
   - More complex code (harder to maintain)
   
   REJECTED ALTERNATIVES:
   - Blocking queue: Too slow
   - Single-producer optimisation: Need multiple producers
   - Unbounded buffer: Memory exhaustion risk
```

---

*Materials developed by Revolvix for ASE Bucharest â€” CSIE*
