# C12_05_FORMATIVE_ASSESSMENT.yaml
# Course 12: File System (Part 2 - Allocation, Structures)
# Formative Assessment â€” Conceptual Quiz

metadata:
  course: 12
  subject: "File System (Part 2 - Allocation, Structures)"
  version: "2.0"
  creation_date: "2026-01-28"
  author: "by Revolvix"
  question_count: 12
  estimated_time_minutes: 15
  bloom_distribution:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

questions:
  - id: q01
    bloom: remember
    difficulty: easy
    text: "What are the 3 main methods of allocating disk space for files?"
    options:
      - "Fast, slow, medium"
      - "Contiguous, linked, indexed"
      - "FIFO, LIFO, random"
      - "Read, write, execute"
    correct: 1
    explanation: "Contiguous: consecutive blocks. Linked: linked lists. Indexed: pointer table (e.g. inode)."

  - id: q02
    bloom: remember
    difficulty: easy
    text: "What is a bitmap in the context of free space management?"
    options:
      - "A graphical image"
      - "A bit vector where each bit indicates whether a block is free (0) or occupied (1)"
      - "A compression algorithm"
      - "A file type"
    correct: 1
    explanation: "Bitmap: space-efficient (1 bit/block), allows rapid discovery of consecutive free blocks."

  - id: q03
    bloom: remember
    difficulty: easy
    text: "What is FAT (File Allocation Table)?"
    options:
      - "A partition type"
      - "A table containing for each block the number of the next block in the file"
      - "A sorting algorithm"
      - "A network protocol"
    correct: 1
    explanation: "FAT: centralised linked allocation. FAT[i] = next block of the file using block i."

  - id: q04
    bloom: understand
    difficulty: medium
    text: "What is the main advantage of contiguous allocation?"
    options:
      - "Space efficiency"
      - "Very fast sequential and random access (a single seek)"
      - "Ease of extension"
      - "It has no advantages"
    correct: 1
    explanation: "Contiguous: a single seek for any access, excellent performance. Disadvantage: external fragmentation."

  - id: q05
    bloom: understand
    difficulty: medium
    text: "Why does linked allocation have slow random access?"
    options:
      - "It is more secure"
      - "You must traverse the list from the beginning to the desired block"
      - "It uses encryption"
      - "It is not slow"
    correct: 1
    explanation: "For block N, N-1 blocks must be read to follow the pointers. O(n) vs O(1)."

  - id: q06
    bloom: understand
    difficulty: medium
    text: "What problem do extents solve in modern filesystems (ext4)?"
    options:
      - "Security"
      - "Reduces overhead for large contiguous files (stores start:length interval instead of individual pointers)"
      - "Increases network speed"
      - "Automatic compression"
    correct: 1
    explanation: "Extent = (start_block, length). A contiguous 1GB file: 1 extent vs thousands of pointers."

  - id: q07
    bloom: understand
    difficulty: medium
    text: "Why is VFS (Virtual File System) useful in Linux?"
    options:
      - "Increases speed"
      - "Provides a uniform interface for all filesystems (ext4, FAT, NFS...)"
      - "Encrypts data"
      - "Manages memory"
    correct: 1
    explanation: "VFS: abstraction. Applications use the same syscalls regardless of the physical filesystem."

  - id: q08
    bloom: understand
    difficulty: medium
    text: "What is a mount point?"
    options:
      - "A hardware type"
      - "The directory where a filesystem becomes accessible in the file hierarchy"
      - "A boot partition"
      - "A network server"
    correct: 1
    explanation: "Mount: attaches the filesystem to a directory. E.g. /mnt/usb makes the USB accessible."

  - id: q09
    bloom: analyse
    difficulty: hard
    text: "A 1MB file on FAT32 with 32KB clusters. How many FAT entries are required?"
    options:
      - "1"
      - "32"
      - "1024"
      - "1048576"
    correct: 1
    explanation: "1MB / 32KB = 32 clusters. Each cluster has one FAT entry, therefore 32 entries."

  - id: q10
    bloom: analyse
    difficulty: hard
    text: "Why is metadata-only journaling faster than full journaling?"
    options:
      - "It is not faster"
      - "It writes only metadata (inodes, directories) to the journal, not file data"
      - "It uses compression"
      - "It deletes the journal more frequently"
    correct: 1
    explanation: "Metadata journaling: less journal I/O. Risk: data may be corrupted, metadata remains intact."

  - id: q11
    bloom: analyse
    difficulty: hard
    text: "What is the trade-off for large vs small block size?"
    options:
      - "There is no trade-off"
      - "Large: less management overhead but more internal fragmentation. Small: the opposite"
      - "Large is always better"
      - "Small is always better"
    correct: 1
    explanation: "Large block: efficient for large files, wasteful for small ones. Small block: the opposite."

  - id: q12
    bloom: apply
    difficulty: hard
    text: "You have an SSD and an HDD. What filesystem features do you prefer for each?"
    options:
      - "The same for both"
      - "SSD: TRIM support, no defragmentation. HDD: periodic defragmentation, write cache"
      - "HDD: TRIM. SSD: defragmentation"
      - "Storage type does not matter"
    correct: 1
    explanation: "SSD: TRIM for garbage collection, wear levelling. HDD: defragmentation (seek time matters)."
