<!-- RO: TRADUS ȘI VERIFICAT -->
# C09_05_FORMATIVE_ASSESSMENT.yaml
# Course 9: Memory Management (Part 1 - Paging, Segmentation)
# Formative Assessment — Conceptual Quiz

metadata:
  course: 9
  subject: "Memory Management (Part 1 - Paging, Segmentation)"
  version: "2.0"
  creation_date: "2026-01-28"
  author: "by Revolvix"
  number_of_questions: 12
  estimated_time_minutes: 15
  bloom_distribution:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

questions:
  # ═══════════════════════════════════════════════════════════════════════════
  # REMEMBER (3 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    bloom: remember
    difficulty: easy
    text: "What is a logical (virtual) address?"
    options:
      - "The physical address in RAM"
      - "The address generated by CPU, seen by the process"
      - "The address on disk"
      - "The IP address"
    correct: 1
    explanation: "Logical address = address seen by the program; translated by MMU into physical address."

  - id: q02
    bloom: remember
    difficulty: easy
    text: "What is paging?"
    options:
      - "Dividing the program into functions"
      - "Dividing memory into fixed-size blocks (pages and frames)"
      - "Memory compression"
      - "Data encryption"
    correct: 1
    explanation: "Paging: logical space into pages, physical memory into frames of the same size."

  - id: q03
    bloom: remember
    difficulty: easy
    text: "What does a Page Table entry contain?"
    options:
      - "The program code"
      - "The physical frame number and control bits (valid, dirty, protection)"
      - "The IP address"
      - "The user password"
    correct: 1
    explanation: "PTE: frame number + valid bit + dirty bit + protection bits + reference bit."

  # ═══════════════════════════════════════════════════════════════════════════
  # UNDERSTAND (5 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q04
    bloom: understand
    difficulty: medium
    text: "What is the difference between internal and external fragmentation?"
    options:
      - "They are identical"
      - "Internal: wasted space within allocated blocks. External: free space fragmented between blocks"
      - "External does not exist"
      - "Internal only occurs on disk"
    correct: 1
    explanation: "Internal: last frame partially used. External: free blocks too small for large requests."

  - id: q05
    bloom: understand
    difficulty: medium
    text: "Why does paging eliminate external fragmentation?"
    options:
      - "It does not eliminate it"
      - "Any free frame can be used for any page; contiguity does not matter"
      - "Pages are compressed"
      - "Frames are larger"
    correct: 1
    explanation: "Frames have fixed size and are interchangeable; contiguous blocks are not required."

  - id: q06
    bloom: understand
    difficulty: medium
    text: "What is segmentation and how does it differ from paging?"
    options:
      - "It is identical to paging"
      - "Segmentation: logical units of variable sizes (code, data, stack); paging: fixed-size blocks"
      - "Segmentation is faster"
      - "Paging does not exist on modern systems"
    correct: 1
    explanation: "Segmentation: logical division, variable sizes. Paging: physical division, fixed sizes."

  - id: q07
    bloom: understand
    difficulty: medium
    text: "What role does the MMU (Memory Management Unit) play?"
    options:
      - "It manages the network"
      - "It translates logical addresses into physical addresses in hardware"
      - "It compiles programs"
      - "It stores passwords"
    correct: 1
    explanation: "MMU = dedicated hardware for address translation and protection checking on every access."

  - id: q08
    bloom: understand
    difficulty: medium
    text: "Why is the page size usually a power of 2 (e.g. 4KB)?"
    options:
      - "For aesthetics"
      - "It allows extracting the offset and page number through simple bit operations"
      - "It saves energy"
      - "It is a tradition with no technical reason"
    correct: 1
    explanation: "Power of 2: offset = last k bits, page number = remainder. Fast operations, no division."

  # ═══════════════════════════════════════════════════════════════════════════
  # ANALYSE (3 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q09
    bloom: analyse
    difficulty: hard
    text: "A system has 32-bit addresses and 4KB pages. How many entries can the page table have?"
    options:
      - "1024"
      - "1 million (2^20)"
      - "4 billion"
      - "4096"
    correct: 1
    explanation: "4KB = 2^12 offset. 32-12 = 20 bits for page number → 2^20 ≈ 1 million possible entries."

  - id: q10
    bloom: analyse
    difficulty: hard
    text: "Why are multi-level page tables used?"
    options:
      - "For speed"
      - "To save memory: we do not allocate entries for unused pages"
      - "For security"
      - "They are not used in practice"
    correct: 1
    explanation: "Multi-level PT: we allocate tables only for used regions, not for the entire address space."

  - id: q11
    bloom: analyse
    difficulty: hard
    text: "What is the trade-off for page size: small vs large?"
    options:
      - "There is no trade-off"
      - "Small: less internal fragmentation but more PT entries. Large: less PT overhead but more internal fragmentation"
      - "Large is always better"
      - "Small is always better"
    correct: 1
    explanation: "Small pages: memory efficiency, large PT. Large pages: small PT, efficient I/O transfer, fragmentation."

  # ═══════════════════════════════════════════════════════════════════════════
  # APPLY (1 question)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q12
    bloom: apply
    difficulty: hard
    text: "Logical address 0x00003A7F on a system with 4KB pages (12-bit offset). What is the page number?"
    options:
      - "0x3A7F"
      - "0x3"
      - "0xA7F"
      - "0x00003"
    correct: 1
    explanation: "0x00003A7F: last 12 bits (0xA7F) = offset. Remainder (0x3) = page number."
