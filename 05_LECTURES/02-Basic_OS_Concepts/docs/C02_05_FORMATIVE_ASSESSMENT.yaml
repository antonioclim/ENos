/* FIȘIER TRADUS ȘI VERIFICAT ÎN LIMBA ROMÂNĂ */

# C02_05_FORMATIVE_ASSESSMENT.yaml
# Course 2: Basic OS Concepts
# Formative Assessment — Conceptual Quiz

metadata:
  course: 2
  subject: "Basic OS Concepts"
  version: "2.0"
  creation_date: "2026-01-28"
  author: "by Revolvix"
  type: "conceptual_quiz"
  number_of_questions: 12
  estimated_time_minutes: 15
  bloom_distribution:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

questions:
  # ═══════════════════════════════════════════════════════════════════════════
  # REMEMBER (3 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    type: mcq
    bloom: remember
    difficulty: easy
    text: "What is an interrupt?"
    options:
      - "A fatal system error"
      - "A hardware/software signal that requests CPU attention"
      - "A jump instruction"
      - "A type of memory"
    correct: 1
    explanation: "Interrupts are signals that cause the CPU to suspend current execution and execute a handler."
    reference: "README.md, section 'Interrupts'"

  - id: q02
    type: mcq
    bloom: remember
    difficulty: easy
    text: "What is the difference between an interrupt and a trap?"
    options:
      - "They are identical"
      - "Interrupt is hardware, trap is software (synchronous)"
      - "Trap is faster"
      - "Interrupt is generated by applications"
    correct: 1
    explanation: "Interrupt = asynchronous, generated by hardware. Trap = synchronous, generated by software (system call, exception)."
    reference: "README.md, section 'Interrupt vs Trap'"

  - id: q03
    type: mcq
    bloom: remember
    difficulty: easy
    text: "What does the Interrupt Vector Table (IVT) contain?"
    options:
      - "The list of all processes"
      - "The addresses of handling routines for each interrupt type"
      - "System passwords"
      - "Hardware configuration"
    correct: 1
    explanation: "The IVT maps each interrupt number to the address of the corresponding handler."
    reference: "README.md, section 'Interrupt Vector Table'"

  # ═══════════════════════════════════════════════════════════════════════════
  # UNDERSTAND (5 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q04
    type: mcq
    bloom: understand
    difficulty: medium
    text: "Why must processor context be saved when handling an interrupt?"
    options:
      - "To clear memory"
      - "To be able to return to the exact state before the interrupt"
      - "To speed up processing"
      - "It is not necessary"
    correct: 1
    explanation: "The context (registers, PC, flags) must be saved so that the interrupted process can continue correctly."
    reference: "README.md, section 'Context Switching'"

  - id: q05
    type: mcq
    bloom: understand
    difficulty: medium
    text: "What does DMA (Direct Memory Access) mean?"
    options:
      - "A type of RAM"
      - "Data transfer between I/O and memory without CPU involvement"
      - "A network protocol"
      - "An encryption method"
    correct: 1
    explanation: "DMA allows I/O devices to transfer data directly to/from memory, freeing the CPU."
    reference: "README.md, section 'DMA'"

  - id: q06
    type: mcq
    bloom: understand
    difficulty: medium
    text: "What is polling and why is it inefficient?"
    options:
      - "Polling = active waiting, CPU checks repeatedly, wasting cycles"
      - "Polling = hardware interrupts"
      - "Polling is very efficient"
      - "Polling = DMA transfer"
    correct: 0
    explanation: "In polling, the CPU constantly checks the device status (busy-wait), wasting cycles on waiting."
    reference: "README.md, section 'Polling vs Interrupts'"

  - id: q07
    type: mcq
    bloom: understand
    difficulty: medium
    text: "What role does the Program Counter (PC) register play?"
    options:
      - "Stores the result of the last operation"
      - "Contains the address of the next instruction to execute"
      - "Counts active processes"
      - "Manages cache memory"
    correct: 1
    explanation: "PC (or IP - Instruction Pointer) indicates the address of the next instruction the CPU will execute."
    reference: "README.md, section 'CPU Registers'"

  - id: q08
    type: mcq
    bloom: understand
    difficulty: medium
    text: "Why do interrupts have priorities?"
    options:
      - "To order them alphabetically"
      - "To allow critical interrupts to preempt less important ones"
      - "To execute them in FIFO order"
      - "They do not have priorities"
    correct: 1
    explanation: "Priorities allow urgent interrupts (e.g. hardware error) to interrupt less critical handlers."
    reference: "README.md, section 'Interrupt Priorities'"

  # ═══════════════════════════════════════════════════════════════════════════
  # ANALYSE (3 questions)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q09
    type: mcq
    bloom: analyse
    difficulty: hard
    text: "A system receives interrupts from the keyboard (priority 2) and disk (priority 5). During the keyboard handler, a disk interrupt arrives. What happens?"
    options:
      - "Disk waits until keyboard finishes"
      - "Disk interrupt preempts the keyboard handler (5 > 2)"
      - "Both execute simultaneously"
      - "System freezes"
    correct: 1
    explanation: "Higher priority interrupts can preempt lower priority handlers (nested interrupts)."
    reference: "README.md, section 'Nested Interrupts'"

  - id: q10
    type: mcq
    bloom: analyse
    difficulty: hard
    text: "Why is bottom-half processing (tasklets, workqueues) used in interrupt handling?"
    options:
      - "To completely eliminate interrupts"
      - "To minimise the time during which interrupts are disabled"
      - "To increase the number of interrupts"
      - "It is not used in modern systems"
    correct: 1
    explanation: "Bottom-half defers non-critical work, allowing the handler to finish quickly and re-enable interrupts."
    reference: "README.md, section 'Top-half vs Bottom-half'"

  - id: q11
    type: mcq
    bloom: analyse
    difficulty: hard
    text: "What happens if an interrupt handler does not clear the device's interrupt flag?"
    options:
      - "Nothing, the system continues normally"
      - "The system may enter an infinite interrupt loop"
      - "The device stops"
      - "A trap is automatically generated"
    correct: 1
    explanation: "If the flag remains set, the device continues to generate interrupts → interrupt storm."
    reference: "README.md, section 'Acknowledging Interrupts'"

  # ═══════════════════════════════════════════════════════════════════════════
  # APPLY (1 question)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q12
    type: mcq
    bloom: apply
    difficulty: hard
    text: "You are designing a driver for a sensor that sends data every 100μs. Which I/O strategy do you choose?"
    context: |
      The sensor generates data very frequently. The CPU must remain available for other tasks.
    options:
      - "Polling every 50μs"
      - "DMA with circular buffer and interrupt when buffer is full"
      - "Interrupt for each data packet"
      - "Ignoring the sensor"
    correct: 1
    explanation: "DMA with buffering reduces overhead; interrupt only when buffer is full minimises context switches."
    reference: "README.md, section 'I/O Strategies'"

statistics:
  total_questions: 12
  by_bloom:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1
  by_difficulty:
    easy: 3
    medium: 5
    hard: 4
