# C17_05_FORMATIVE_ASSESSMENT.yaml
# Course 17 Supplementary: Kernel Level OS Programming
# Formative Assessment â€” Conceptual Quiz

metadata:
  course: 17
  subject: "Kernel Level OS Programming"
  version: "2.0"
  creation_date: "2026-01-28"
  author: "by Revolvix"
  number_of_questions: 10
  estimated_time_minutes: 12
  bloom_distribution:
    remember: 2
    understand: 4
    analyse: 3
    apply: 1

questions:
  - id: q01
    bloom: remember
    difficulty: easy
    text: "What is a kernel module in Linux?"
    options:
      - "A type of application"
      - "Code that can be loaded/unloaded from the kernel at runtime without recompiling the kernel"
      - "A configuration file"
      - "A network protocol"
    correct: 1
    explanation: "Kernel module: extends functionality (drivers, filesystems) dynamically, without reboot."

  - id: q02
    bloom: remember
    difficulty: easy
    text: "Which commands are used to manage modules in Linux?"
    options:
      - "apt install / apt remove"
      - "insmod, rmmod, modprobe, lsmod"
      - "mount, umount"
      - "start, stop, restart"
    correct: 1
    explanation: "insmod: loads. rmmod: unloads. modprobe: resolves dependencies. lsmod: lists."

  - id: q03
    bloom: understand
    difficulty: medium
    text: "Why must kernel code be very careful about errors?"
    options:
      - "It does not need to be"
      - "A bug in the kernel = kernel panic or security vulnerability; there is no protection as in userspace"
      - "For speed"
      - "For aesthetic reasons"
    correct: 1
    explanation: "Kernel: maximum privileges, direct hardware access. Bug = system crash or root exploit."

  - id: q04
    bloom: understand
    difficulty: medium
    text: "What are the init_module() and cleanup_module() functions in a kernel module?"
    options:
      - "Debugging functions"
      - "Entry/exit points: init at insmod, cleanup at rmmod"
      - "Network functions"
      - "Storage functions"
    correct: 1
    explanation: "module_init(): setup at load. module_exit(): cleanup at unload. Mandatory."

  - id: q05
    bloom: understand
    difficulty: medium
    text: "Why can you not use printf() in the kernel?"
    options:
      - "It is too slow"
      - "printf() is from libc (userspace). In kernel you use printk() with log levels"
      - "The kernel has no output"
      - "printf() is deprecated"
    correct: 1
    explanation: "Kernel does not have libc. printk(KERN_INFO ...) writes to kernel log (dmesg)."

  - id: q06
    bloom: understand
    difficulty: medium
    text: "What is a character device driver?"
    options:
      - "A keyboard driver"
      - "A driver that provides sequential access to a device through read/write operations on a file in /dev"
      - "A hard disk driver"
      - "A GPU driver"
    correct: 1
    explanation: "Char device: stream of bytes (terminal, serial). Block device: random access, blocks (disk)."

  - id: q07
    bloom: analyse
    difficulty: hard
    text: "Why are spinlocks preferred over mutexes in interrupt handlers?"
    options:
      - "They are safer"
      - "Mutexes can sleep; in interrupt context you cannot sleep (there is no process to schedule)"
      - "Spinlocks are slower"
      - "There is no difference"
    correct: 1
    explanation: "Interrupt: no process context, cannot sleep. Spinlock: busy-wait, OK for short durations."

  - id: q08
    bloom: analyse
    difficulty: hard
    text: "What is eBPF and why is it revolutionary for kernel programming?"
    options:
      - "A type of firewall"
      - "It allows running custom code in the kernel safely (sandbox) without writing traditional modules"
      - "A network protocol"
      - "A filesystem"
    correct: 1
    explanation: "eBPF: verified program, sandbox in kernel. Tracing, networking, security without crash risk."

  - id: q09
    bloom: analyse
    difficulty: hard
    text: "What is the main risk when writing a kernel module?"
    options:
      - "It is too slow"
      - "Eroares can cause kernel panic, data corruption or security holes with root privileges"
      - "It consumes too much memory"
      - "There are no risks"
    correct: 1
    explanation: "Kernel module = part of the kernel. Bug = system crash or complete compromise."

  - id: q10
    bloom: apply
    difficulty: hard
    text: "You want to register a handler for a hardware interrupt. Which kernel function do you use?"
    options:
      - "malloc()"
      - "request_irq() / devm_request_irq()"
      - "printf()"
      - "fork()"
    correct: 1
    explanation: "request_irq(irq, handler, flags, name, dev_id) registers your handler for the IRQ."
